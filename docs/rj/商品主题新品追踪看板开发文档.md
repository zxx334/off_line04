商品主题新品追踪看板开发文档
    需求：监控店内上架新品的市场表现和趋势
    数据来源：阿里云服务器MySQL 同步到MaxCompute

一、指标体系

主要数据表：

    product_category - 商品类目表

    product_info - 商品信息表

    product_online_history - 商品上下架记录表

    product_new_tag - 新品标签表

    order_info - 订单主表

    order_item - 订单商品明细表

    shopping_cart - 购物车表

    user_behavior - 用户行为表

    refund_record - 退款记录表

二、功能模块

模块1：最近上新

1.指标清单

    上新30天累计支付金额（核心指标）

    上新时间、商品状态

    商品基础信息：商品ID、商品名称、货号、主图

2. 实现逻辑

    从商品信息表、上架历史表、新品标签表关联获取最新上架商品

    计算每个商品上架后30天内的累计支付金额

    按上架时间倒序排列，展示最新上架的商品
3. 代码实现


        工单编号：大数据-电商数仓-06-商品主题新品追踪看板
    
        def get_recent_new_products():
            """
            最近上新模块 - 滚动展示店铺最新上线商品
            统计新品上架后30天内的累计支付金额
            """
            with o.execute_sql("""
            SELECT 
                pi.product_id,
                pi.product_title,
                pi.product_code,
                pi.product_image,
                poh.online_date,
                poh.online_time,
                COALESCE(SUM(CASE 
                    WHEN oi.payment_status = 1 
                    AND oi.payment_time >= poh.online_time 
                    AND oi.payment_time <= DATEADD(poh.online_time, 30, 'dd')
                    THEN oi.payment_amount ELSE 0 
                END), 0) as total_payment_30d,
                ROW_NUMBER() OVER (ORDER BY poh.online_time DESC) as rn
            FROM df_cb_322001.realtime_v2_ods_product_info pi
            INNER JOIN df_cb_322001.realtime_v2_ods_product_online_history poh 
                ON pi.product_id = poh.product_id 
                AND poh.online_status = 1
                AND poh.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_online_history)
            INNER JOIN df_cb_322001.realtime_v2_ods_product_new_tag pnt 
                ON pi.product_id = pnt.product_id 
                AND pnt.is_tmall_new_product = 1
                AND pnt.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_new_tag)
            LEFT JOIN df_cb_322001.realtime_v2_ods_order_info oi 
                ON pi.product_id = oi.product_id 
                AND oi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_order_info)
            WHERE pi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_info)
                AND poh.online_time IS NOT NULL
            GROUP BY 
                pi.product_id, pi.product_title, pi.product_code, pi.product_image, 
                poh.online_date, poh.online_time
            HAVING total_payment_30d >= 0
            ORDER BY poh.online_time DESC
            LIMIT 50
            """).open_reader() as reader:
                for record in reader:
                print(record)

模块2：新品监控（周期汇总）

1.指标体系

    指标类别	具体指标

    销售表现	支付金额、支付件数、支付买家数
    转化效果	支付转化率 = 支付买家数/访客数
    流量表现	访客数、浏览量
    运营效率	新品动销率 = 有销售的新品数/总新品数
筛选条件：时间周期、商品类目、价格段等。

2.实现逻辑

    关联商品信息表、上架历史表、新品标签表、订单信息表、用户行为表

    统计最近30天内新品的核心业务指标

    计算转化率等效率指标

3.代码实现


    def get_new_product_monitoring():
        """
        新品监控模块 - 统计店铺新品整体运营情况
        数据统计为当天上新商品30天内的累计数据
        """
        with o.execute_sql("""
        SELECT 
            '最近30天' as period_type,
            COUNT(DISTINCT pi.product_id) as new_product_count,
            COALESCE(SUM(CASE 
                WHEN oi.payment_status = 1 
                AND oi.payment_time >= poh.online_time 
                AND oi.payment_time <= DATEADD(poh.online_time, 30, 'dd')
                THEN oi.payment_amount ELSE 0 
            END), 0) as total_payment_amount,
            COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.order_id END) as total_order_count,
            COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.user_id END) as total_user_count,
            CASE 
                WHEN COUNT(DISTINCT ub.user_id) > 0 
                THEN ROUND(COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.order_id END) * 100.0 / COUNT(DISTINCT ub.user_id), 2)
                ELSE 0 
            END as conversion_rate,
            -- 新品动销率计算
            CASE 
                WHEN COUNT(DISTINCT pi.product_id) > 0 
                THEN ROUND(COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN pi.product_id END) * 100.0 / COUNT(DISTINCT pi.product_id), 2)
                ELSE 0 
            END as sales_ratio
        FROM df_cb_322001.realtime_v2_ods_product_info pi
        INNER JOIN df_cb_322001.realtime_v2_ods_product_online_history poh 
            ON pi.product_id = poh.product_id 
            AND poh.online_status = 1
            AND poh.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_online_history)
        INNER JOIN df_cb_322001.realtime_v2_ods_product_new_tag pnt 
            ON pi.product_id = pnt.product_id 
            AND pnt.is_tmall_new_product = 1
            AND pnt.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_new_tag)
        LEFT JOIN df_cb_322001.realtime_v2_ods_order_info oi 
            ON pi.product_id = oi.product_id 
            AND oi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_order_info)
        LEFT JOIN (
            SELECT user_id, product_id 
            FROM df_cb_322001.realtime_v2_ods_user_behavior 
            WHERE ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_user_behavior)
            AND behavior_type = 'pv'
            GROUP BY user_id, product_id
        ) ub ON pi.product_id = ub.product_id
        WHERE pi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_info)
            AND poh.online_time IS NOT NULL
        GROUP BY '最近30天'
        """).open_reader() as reader:
            for record in reader:
                print(record)

模块3：新品全年复盘
1.核心指标

    单日上新商品数

    单日新品总支付金额

    月度/季度新品表现汇总

2.实现逻辑

    按上架日期分组统计每日新品数据

    计算每日新品数量和30天内支付总额

    提取年月日信息用于时间维度分析

3.代码实现

    def get_annual_review():
        """
        新品全年复盘模块 - 分析全年不同日期的上线新品表现
        热力方格代表支付金额，用于复盘分析
        """
        with o.execute_sql("""
        SELECT 
            poh.online_date,
            COUNT(DISTINCT pi.product_id) as new_product_count,
            COALESCE(SUM(CASE 
                WHEN oi.payment_status = 1 
                AND oi.payment_time >= poh.online_time 
                AND oi.payment_time <= DATEADD(poh.online_time, 30, 'dd')
                THEN oi.payment_amount ELSE 0 
            END), 0) as total_payment_30d,
            YEAR(poh.online_date) as year,
            MONTH(poh.online_date) as month,
            DAY(poh.online_date) as day,
            -- 月度汇总标识
            CONCAT(YEAR(poh.online_date), '-', LPAD(MONTH(poh.online_date), 2, '0')) as year_month
        FROM df_cb_322001.realtime_v2_ods_product_info pi
        INNER JOIN df_cb_322001.realtime_v2_ods_product_online_history poh 
            ON pi.product_id = poh.product_id 
            AND poh.online_status = 1
            AND poh.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_online_history)
        INNER JOIN df_cb_322001.realtime_v2_ods_product_new_tag pnt 
            ON pi.product_id = pnt.product_id 
            AND pnt.is_tmall_new_product = 1
            AND pnt.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_new_tag)
        LEFT JOIN df_cb_322001.realtime_v2_ods_order_info oi 
            ON pi.product_id = oi.product_id 
            AND oi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_order_info)
        WHERE pi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_info)
            AND poh.online_time IS NOT NULL
            AND poh.online_date >= DATE_SUB(CURRENT_DATE, 365)
        GROUP BY 
            poh.online_date,
            YEAR(poh.online_date),
            MONTH(poh.online_date),
            DAY(poh.online_date),
            CONCAT(YEAR(poh.online_date), '-', LPAD(MONTH(poh.online_date), 2, '0'))
        ORDER BY poh.online_date
        """).open_reader() as reader:
            for record in reader:
                print(record)


模块4：新品列表

1.指标维度

    商品基础信息：商品ID、商品名称、类目、价格

    新品标签：普通新品 / 小黑盒新品

    运营指标：支付金额、支付件数、访客数、加购人数、收藏人数

    效率指标：支付转化率、加购率、收藏率

    筛选功能：按新品标签、类目、时间范围筛选

2.实现逻辑

    关联多个业务表获取商品完整信息

    按商品分组统计30天内的核心指标

    支持按支付金额排序和分页显示

3.代码实现

    def get_new_product_list():
        """
        新品列表模块 - 查看不同类目单品新品期间的运营效果
        支持普通新品和小黑盒新品筛选，数据统计周期为新品首次上新后的30天
        """
        with o.execute_sql("""
        SELECT 
            pi.product_id,
            pi.product_title,
            pi.product_code,
            pc.category_name,
            pnt.new_product_type,
            poh.online_date,
            pi.product_price,
            COALESCE(SUM(CASE 
                WHEN oi.payment_status = 1 
                AND oi.payment_time >= poh.online_time 
                AND oi.payment_time <= DATEADD(poh.online_time, 30, 'dd')
                THEN oi.payment_amount ELSE 0 
            END), 0) as total_payment_30d,
            COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.order_id END) as total_sales_30d,
            COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.user_id END) as total_buyers_30d,
            COUNT(DISTINCT ub.user_id) as visitor_count,
            COUNT(DISTINCT sc.user_id) as cart_user_count,
            COUNT(DISTINCT fav.user_id) as favorite_user_count,
            CASE 
                WHEN COUNT(DISTINCT ub.user_id) > 0 
                THEN ROUND(COUNT(DISTINCT CASE WHEN oi.payment_status = 1 THEN oi.order_id END) * 100.0 / COUNT(DISTINCT ub.user_id), 2)
                ELSE 0 
            END as conversion_rate_30d,
            CASE 
                WHEN COUNT(DISTINCT ub.user_id) > 0 
                THEN ROUND(COUNT(DISTINCT sc.user_id) * 100.0 / COUNT(DISTINCT ub.user_id), 2)
                ELSE 0 
            END as cart_rate,
            CASE 
                WHEN COUNT(DISTINCT ub.user_id) > 0 
                THEN ROUND(COUNT(DISTINCT fav.user_id) * 100.0 / COUNT(DISTINCT ub.user_id), 2)
                ELSE 0 
            END as favorite_rate
        FROM df_cb_322001.realtime_v2_ods_product_info pi
        INNER JOIN df_cb_322001.realtime_v2_ods_product_online_history poh 
            ON pi.product_id = poh.product_id 
            AND poh.online_status = 1
            AND poh.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_online_history)
        INNER JOIN df_cb_322001.realtime_v2_ods_product_category pc 
            ON pi.category_id = pc.category_id 
            AND pc.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_category)
        INNER JOIN df_cb_322001.realtime_v2_ods_product_new_tag pnt 
            ON pi.product_id = pnt.product_id 
            AND pnt.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_new_tag)
        LEFT JOIN df_cb_322001.realtime_v2_ods_order_info oi 
            ON pi.product_id = oi.product_id 
            AND oi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_order_info)
        LEFT JOIN (
            SELECT user_id, product_id 
            FROM df_cb_322001.realtime_v2_ods_user_behavior 
            WHERE ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_user_behavior)
            AND behavior_type = 'pv'
            GROUP BY user_id, product_id
        ) ub ON pi.product_id = ub.product_id
        LEFT JOIN (
            SELECT user_id, product_id 
            FROM df_cb_322001.realtime_v2_ods_shopping_cart 
            WHERE ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_shopping_cart)
            GROUP BY user_id, product_id
        ) sc ON pi.product_id = sc.product_id
        LEFT JOIN (
            SELECT user_id, product_id 
            FROM df_cb_322001.realtime_v2_ods_user_behavior 
            WHERE ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_user_behavior)
            AND behavior_type = 'fav'
            GROUP BY user_id, product_id
        ) fav ON pi.product_id = fav.product_id
        WHERE pi.ds = (SELECT MAX(ds) FROM df_cb_322001.realtime_v2_ods_product_info)
            AND poh.online_time IS NOT NULL
            AND poh.online_date >= DATE_SUB(CURRENT_DATE, 60)
        GROUP BY 
            pi.product_id, pi.product_title, pi.product_code, pc.category_name,
            pnt.new_product_type, poh.online_date, pi.product_price
        HAVING total_payment_30d >= 0
        ORDER BY total_payment_30d DESC
        LIMIT 200
        """).open_reader() as reader:
            for record in reader:
                print(record)

三、完整执行脚本

工单编号：大数据-电商数仓-06-商品主题新品追踪看板

 技术栈：Python 3.10 + PySpark SQL (Spark 3.2+)


    def main():
        """
        新品追踪看板主函数
        执行所有模块的数据查询和展示
        """
        print("开始执行新品追踪看板数据查询...")
        
        # 执行最近上新模块
        print("\n=== 最近上新模块 ===")
        get_recent_new_products()
        
        # 执行新品监控模块
        print("\n=== 新品监控模块 ===")
        get_new_product_monitoring()
        
        # 执行全年复盘模块
        print("\n=== 新品全年复盘模块 ===")
        get_annual_review()
        
        # 执行新品列表模块
        print("\n=== 新品列表模块 ===")
        get_new_product_list()
        
        print("\n新品追踪看板数据查询完成！")

    if __name__ == "__main__":
        main()

四、技术实现

1. 环境

    Python 3.10

    PySpark SQL (Spark 3.2+)

    MySQL 数据源 ——> MaxCompute

2.数据分层说明

    ODS层：原始数据层，直接对接业务数据库

    ADS层：应用数据层，经过加工处理的指标数据

3.性能优化

    使用分区字段(ds)进行数据过滤

    对常用查询字段建立索引

    使用LEFT JOIN避免数据丢失

    使用COALESCE处理空值

4.业务规则

    新品定义：具有天猫新品标签的商品

    统计周期：商品上架后30天内

    数据更新：每日定时更新最新分区数据

